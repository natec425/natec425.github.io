    Title: AI Reuse pt 1
    Date: 2016-09-16T20:18:29
    Tags: Functional Programming, Elm, Pokemon, AI

I thought a list of independently playing Voltorb Flip AIs would be pretty neat.
So, I did it.
Right now, it is my original "expectation" based AI alongside a random AI. I wanted to add a simple
learning AI this week, but I started too late. However, I did learn to appreciate
some important differences and similarities in the nature of the random AI and the
(soon to be) learning AI.

<!-- more -->

### Plugging In A New Brain

Of course, I refuse to copy/paste/edit my original AI to produce a new one. What
I need isn't hotkeys, what I need is parameters. So, I Extreme Makeover'd my
AI.Core.Model type alias from this:

```elm
type alias Model =
      { wins : Int
      , losses : Int
      , points : Int
      , gameModel : Game.Core.Model
      , playing : Bool }
```

to this:

```elm
type alias Model =
    { wins : Int
    , losses : Int
    , points : Int
    , gameModel : Game.Core.Model
    , playing : Bool
    , play : Board -> (Game.Core.Model, Cmd Game.Core.Msg) }
```

Of course, I had to make an change in the update function to call the new ```model.play```,
but it was a pretty minor change for pretty reasonable gain. If you are interested in seeing
the diff, [here it is][play-handler-diff].

This will change next week, but it is good enough for the random AI. The reason why it is sufficient
for the random AI but (kinda) insufficient for the learning AI has to do with Elm's purity and managed
effects. My random ai's play function can use the provided Random effect manager to create a Cmd that
generates a random Game.Core.Expose Msg. All of the impurity is handled very neatly in the Random effects
manager, my AI doesn't need to own any of it. The important thing to remember is the state still exists;
it is just hidden inside the Random effect manager.

A knee-jerk strategy could be to implement some sort of Learn effect manager. This just feels like a
bad idea to me. I'm honestly not even going to entertain it for long. I feel like the problem is the
AI.Core.Model not being sufficiently general. I was able to get by this week thanks to Random having
such an easy out with prepackaged managed state, but next week I have a more specialized type of state
that should probably be handled inside the AI's Model somehow. I have an idea of how I will do it, but
for now, on to using the multiple AIs.

### Multiple Independent AIs

So the next step is smashing all of your AIs into one Model and dispatching updates appropriately!
Sounds simple enough.

```elm
type alias Model = Array AI.Core.Model

type Msg
    = Msg Int AI.Core.Msg
```

Now, inside the update function, each message comes with an Int telling me which AI the AI.Core.Msg
is for. Surprisingly easy.

So here are the two AIs. I'll let you guess which one is playing randomly and which one is
actually trying.

<div id="voltorb-flip"></div>
<script src="/js/voltorb-flip-multiai.js"></script>
<script>
    var node = document.getElementById('voltorb-flip');
    var app = Elm.MultiAI.embed(node);
</script>
</div>

[play-handler-diff]: https://github.com/natec425/voltorb-flip/commit/ad4feebf87f694aeef5806876c2b953293c5d881